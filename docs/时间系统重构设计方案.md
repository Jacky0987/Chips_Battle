# 游戏时间系统重构设计方案

## 1. 现状问题分析

### 1.1 当前时间系统存在的问题

#### 问题1：虚拟时间与实际时间混用
- **问题描述**：代码中同时使用了游戏虚拟时间和系统实际时间
- **具体表现**：
  - `TimeService._process_tick()` 中使用 `datetime.now()` 记录tick 开始时间和事件时间戳
  - `TimeTickEvent` 的 `timestamp` 字段使用实际时间而非游戏时间
  - 统计信息中混用了实际时间和游戏时间
  - 部分模型（如 `BaseModel.refresh_timestamps()`）直接使用 `datetime.now()`

#### 问题2：Tick系统仅作触发器而非真正的时间系统
- **问题描述**：当前tick系统只是定时触发事件，而不是作为游戏世界的时间基准
- **具体表现**：
  - tick间隔固定为实际时间60秒，无法实现时间流速控制
  - 游戏时间推进与tick频率耦合，无法独立调整
  - 缺乏统一的时间获取接口

#### 问题3：时间流速控制不完善
- **问题描述**：虽然有 `hours_per_tick` 参数，但实际应用中存在局限
- **具体表现**：
  - 无法实现实时的时间流速调整（如2x、3x加速）
  - 时间暂停功能不够完善
  - 缺乏时间倒流或快进功能

#### 问题4：服务间时间依赖不一致
- **问题描述**：不同服务对时间的使用方式不统一
- **具体表现**：
  - `StockService` 正确使用游戏时间进行股价更新
  - `NewsService` 正确使用游戏时间创建新闻
  - 但事件系统和统计系统仍使用实际时间

## 2. 设计目标

### 2.1 核心目标
1. **统一时间源**：所有游戏逻辑使用统一的虚拟时间系统
2. **灵活的时间控制**：支持暂停、加速、减速、快进等时间操作
3. **清晰的时间边界**：明确区分游戏时间和系统时间的使用场景
4. **高性能**：时间系统不应成为游戏性能瓶颈
5. **易于扩展**：支持未来添加更复杂的时间机制

### 2.2 功能需求
1. **基础时间管理**：游戏时间的获取、设置、推进
2. **时间流速控制**：支持0.5x、1x、2x、3x等不同流速
3. **时间操作**：暂停、恢复、快进、设置特定时间
4. **事件调度**：基于游戏时间的事件调度系统
5. **时间查询**：提供丰富的时间查询接口

## 3. 新时间系统架构设计

### 3.1 核心组件

#### 3.1.1 GameTimeManager（游戏时间管理器）
```python
class GameTimeManager:
    """游戏时间管理器 - 系统核心"""
    
    def __init__(self):
        self._game_time: datetime  # 当前游戏时间
        self._start_time: datetime  # 游戏开始时间
        self._time_scale: float = 1.0  # 时间流速倍率
        self._is_paused: bool = False  # 是否暂停
        self._last_real_time: float  # 上次更新的实际时间
        self._accumulated_time: float = 0.0  # 累积的游戏时间（秒）
    
    def get_current_time(self) -> datetime:
        """获取当前游戏时间"""
    
    def set_time_scale(self, scale: float):
        """设置时间流速（1.0=正常，2.0=2倍速，0.5=半速）"""
    
    def pause(self):
        """暂停时间"""
    
    def resume(self):
        """恢复时间"""
    
    def advance_time(self, hours: float):
        """手动推进时间"""
    
    def set_time(self, new_time: datetime):
        """设置游戏时间"""
```

#### 3.1.2 TimeEventScheduler（时间事件调度器）
```python
class TimeEventScheduler:
    """基于游戏时间的事件调度器"""
    
    def schedule_at(self, target_time: datetime, callback: Callable):
        """在指定游戏时间执行回调"""
    
    def schedule_after(self, hours: float, callback: Callable):
        """在指定游戏时间后执行回调"""
    
    def schedule_recurring(self, interval_hours: float, callback: Callable):
        """定期执行回调"""
    
    def cancel_event(self, event_id: str):
        """取消事件"""
```

#### 3.1.3 TimeService（重构后的时间服务）
```python
class TimeService:
    """时间服务 - 对外接口层"""
    
    def __init__(self, event_bus: EventBus):
        self.time_manager = GameTimeManager()
        self.scheduler = TimeEventScheduler()
        self.event_bus = event_bus
        self._tick_interval = 1.0  # 实际秒数，用于更新频率
    
    def start(self):
        """启动时间服务"""
    
    def get_game_time(self) -> datetime:
        """获取当前游戏时间"""
        return self.time_manager.get_current_time()
    
    def set_time_scale(self, scale: float):
        """设置时间流速"""
        self.time_manager.set_time_scale(scale)
```

### 3.2 时间流动机制

#### 3.2.1 基于实际时间的连续更新
```python
async def _time_update_loop(self):
    """时间更新循环"""
    while self._running:
        current_real_time = time.time()
        
        if not self._is_paused:
            # 计算实际时间差
            real_delta = current_real_time - self._last_real_time
            
            # 应用时间倍率
            game_delta = real_delta * self._time_scale
            
            # 更新游戏时间
            self._accumulated_time += game_delta
            self._game_time += timedelta(seconds=game_delta)
            
            # 检查并触发事件
            await self._check_and_fire_events()
        
        self._last_real_time = current_real_time
        await asyncio.sleep(self._tick_interval)
```

#### 3.2.2 事件触发机制
```python
async def _check_and_fire_events(self):
    """检查并触发时间事件"""
    current_time = self._game_time
    
    # 检查小时变化
    if self._should_fire_hourly_event():
        await self._fire_hourly_tick()
    
    # 检查日期变化
    if self._should_fire_daily_event():
        await self._fire_daily_tick()
    
    # 检查调度事件
    await self.scheduler.check_and_fire_events(current_time)
```

### 3.3 时间类型定义

#### 3.3.1 时间类型枚举
```python
class TimeType(Enum):
    """时间类型"""
    GAME_TIME = "game_time"      # 游戏时间
    REAL_TIME = "real_time"      # 实际时间
    SYSTEM_TIME = "system_time"  # 系统时间（用于日志、统计等）
```

#### 3.3.2 时间上下文
```python
@dataclass
class TimeContext:
    """时间上下文"""
    game_time: datetime          # 当前游戏时间
    real_time: datetime          # 当前实际时间
    time_scale: float           # 时间倍率
    is_paused: bool            # 是否暂停
    total_game_hours: float    # 总游戏时长（小时）
    session_duration: float    # 会话时长（实际秒数）
```

## 4. 具体实现方案

### 4.1 时间获取接口统一化

#### 4.1.1 创建时间工具类
```python
class GameTime:
    """游戏时间工具类"""
    
    _time_service: Optional['TimeService'] = None
    
    @classmethod
    def set_time_service(cls, time_service: 'TimeService'):
        """设置时间服务实例"""
        cls._time_service = time_service
    
    @classmethod
    def now(cls) -> datetime:
        """获取当前游戏时间"""
        if cls._time_service is None:
            raise RuntimeError("时间服务未初始化")
        return cls._time_service.get_game_time()
    
    @classmethod
    def real_now(cls) -> datetime:
        """获取当前实际时间（仅用于系统级操作）"""
        return datetime.now()
```

#### 4.1.2 替换现有时间调用
```python
# 原来的代码
published_at=datetime.now()

# 修改后的代码
published_at=GameTime.now()
```

### 4.2 事件系统重构

#### 4.2.1 新的时间事件定义
```python
@dataclass
class GameTimeTickEvent(Event):
    """游戏时间滴答事件"""
    game_time: datetime         # 当前游戏时间
    real_timestamp: datetime    # 实际时间戳（用于系统记录）
    time_scale: float          # 当前时间倍率
    hours_elapsed: float       # 本次tick经过的游戏小时数
    tick_type: str            # tick类型：hourly, daily, manual
```

#### 4.2.2 事件发布优化
```python
async def _fire_hourly_tick(self):
    """发布小时tick事件"""
    event = GameTimeTickEvent(
        event_id=f"hourly_tick_{self._tick_count}",
        source="time_service",
        game_time=self.time_manager.get_current_time(),
        real_timestamp=datetime.now(),
        time_scale=self.time_manager.get_time_scale(),
        hours_elapsed=1.0,
        tick_type="hourly"
    )
    await self.event_bus.publish(event)
```

### 4.3 服务层适配

#### 4.3.1 StockService适配
```python
class StockService:
    async def _on_time_tick(self, event: GameTimeTickEvent):
        """处理时间滴答事件"""
        if not self._is_market_hours(event.game_time):
            return
        await self._update_stock_prices(event.game_time)
    
    def _is_market_hours(self, game_time: datetime) -> bool:
        """使用游戏时间判断市场时间"""
        # 使用传入的游戏时间而不是获取当前时间
        return 9 <= game_time.hour < 16 and game_time.weekday() < 5
```

#### 4.3.2 NewsService适配
```python
class NewsService:
    async def _create_news(self, title: str, content: str, **kwargs) -> News:
        """创建新闻记录"""
        news = News(
            title=title,
            content=content,
            published_at=GameTime.now(),  # 使用游戏时间
            **kwargs
        )
        # ... 其他逻辑
```

### 4.4 时间控制命令

#### 4.4.1 时间管理命令
```python
class TimeCommand(BaseCommand):
    """时间管理命令"""
    
    async def execute(self, args: List[str], context: CommandContext) -> CommandResult:
        if not args:
            return await self._show_time_status()
        
        action = args[0].lower()
        
        if action == "pause":
            return await self._pause_time()
        elif action == "resume":
            return await self._resume_time()
        elif action == "speed":
            return await self._set_time_speed(args[1:], context)
        elif action == "advance":
            return await self._advance_time(args[1:], context)
        else:
            return self.error("未知的时间操作")
    
    async def _set_time_speed(self, args: List[str], context: CommandContext) -> CommandResult:
        """设置时间流速"""
        if not args:
            return self.error("请指定时间倍率（如：1.0, 2.0, 0.5）")
        
        try:
            scale = float(args[0])
            if scale < 0:
                return self.error("时间倍率不能为负数")
            
            context.time_service.set_time_scale(scale)
            return self.success(f"时间流速已设置为 {scale}x")
        except ValueError:
            return self.error("无效的时间倍率")
```

## 5. 迁移计划

### 5.1 第一阶段：核心时间系统重构
1. 实现 `GameTimeManager` 核心类
2. 重构 `TimeService` 接口
3. 创建 `GameTime` 工具类
4. 更新时间事件定义

### 5.2 第二阶段：服务层适配
1. 更新 `StockService` 时间使用
2. 更新 `NewsService` 时间使用
3. 更新其他服务的时间依赖
4. 修复模型层的时间使用

### 5.3 第三阶段：功能增强
1. 实现时间控制命令
2. 添加时间事件调度器
3. 完善时间统计和监控
4. 添加时间相关的调试工具

### 5.4 第四阶段：测试和优化
1. 编写全面的时间系统测试
2. 性能优化和调试
3. 文档完善
4. 用户界面优化

## 6. 技术细节

### 6.1 时间精度
- 游戏时间精度：秒级
- 更新频率：每秒更新一次
- 事件触发精度：分钟级

### 6.2 性能考虑
- 时间更新使用异步循环，避免阻塞
- 事件调度使用优先队列优化
- 缓存常用的时间计算结果

### 6.3 数据持久化
- 游戏时间状态保存到配置文件
- 支持游戏重启后恢复时间状态
- 时间相关的统计数据持久化

## 7. 风险评估

### 7.1 技术风险
- **兼容性风险**：现有代码大量使用实际时间，需要仔细迁移
- **性能风险**：频繁的时间更新可能影响性能
- **复杂性风险**：新系统增加了代码复杂度

### 7.2 缓解措施
- 分阶段迁移，确保每个阶段都能正常运行
- 保留原有接口的兼容性包装
- 充分的测试覆盖
- 详细的文档和示例

## 8. 总结

这个重构方案将彻底解决当前时间系统的问题，提供一个统一、灵活、高性能的游戏时间系统。新系统将支持：

1. **统一的时间源**：所有游戏逻辑使用同一个时间系统
2. **灵活的时间控制**：支持暂停、加速、快进等操作
3. **清晰的架构**：明确分离游戏时间和系统时间
4. **易于扩展**：为未来的时间相关功能提供基础

通过这个重构，游戏将拥有一个真正意义上的虚拟时间系统，为玩家提供更好的游戏体验。